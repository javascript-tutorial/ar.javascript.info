# المقارنات 

نحن نعرف الكثير من معاملات المقارنة من الرياضيات 

: وفي لغة الجافسكريبت تكتب كما يلي 

<<<<<<< HEAD
- أكبر/أصغر من: <code>a &gt; b</code>, <code>a &lt; b</code>.
- أكبر/أصغر من او يساوي: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- يساوي: `a == b` ، يرجى ملاحظة أن علامة المساواة المزدوجة` = `تعني اختبار المساواة ، في حين أن كلمة واحدة` a = b` تعني  تعيين أو مساواة .
- لا تساوي. في الرياضيات يكون الترميز <code>&ne;</code> ،لكن في JavaScript تكتب هكذا <code>a != b</code>.
=======
- Greater/less than: <code>a &gt; b</code>, <code>a &lt; b</code>.
- Greater/less than or equals: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Equals: `a == b`, please note the double equality sign `==` means the equality test, while a single one `a = b` means an assignment.
- Not equals: In maths the notation is <code>&ne;</code>, but in JavaScript it's written as <code>a != b</code>.
>>>>>>> ea7738bb7c3616bb51ff14ae3db2a2747d7888ff

في هذه المقالة سنتعلم المزيد عن الأنواع المختلفة من المقارنات ، وكيف تجعلها JavaScript، بما في ذلك الخصائص المهمة.

في النهاية ستجد وصفة جيدة لتجنب المشاكل المتعلقة بـ "مراوغات JavaScript".

## Boolean هي النتيجة

تُرجع جميع عوامل المقارنة قيمة منطقية:

- "صحيح" - يعني "نعم" أو "صحيح" أو "الحقيقة".
- "false" - تعني "لا" أو "خطأ" أو "ليست الحقيقة".

فمثلا:

```js run
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
```

يمكن تعيين نتيجة مقارنة لمتغير ، تمامًا مثل أي قيمة:

```js run
let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
```

## مقارنة الكلمات 

لمعرفة ما إذا كانت السلسلة أكبر من غيرها ، تستخدم جافا سكريبت ما يسمى بترتيب "القاموس" أو "المعجم".

بمعنى آخر ، تتم مقارنة السلاسل حرفًا بحرف.

فمثلا:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

خوارزمية مقارنة سلسلتين بسيطة:

1. قارن الحرف الأول من كلا السلاسل.
2. إذا كان الحرف الأول من السلسلة الأولى أكبر (أو أقل) من السلسلة الأخرى ، فإن السلسلة الأولى أكبر (أو أقل) من السلسلة الثانية. لقد انتهينا.
3. وبخلاف ذلك ، إذا كانت الأحرف الأولى لكلتا السلاسل متشابهة ، قارن الأحرف الثانية بنفس الطريقة.
4. كرر حتى نهاية أي سلسلة.
5. إذا انتهى كلا السلاسل بنفس الطول ، فإنهما متساويان. خلاف ذلك ، فإن السلسلة الأطول أكبر.

في الأمثلة أعلاه ، تصل المقارنة `"Z" > "A"` إلى نتيجة في الخطوة الأولى.

فى المقارنة الثانية `'Glow'` و `'Glee'` يحتاجون إلى مزيد من الخطوات حيث تتم مقارنة السلاسل حرفًا بحرف:

1. "G" هو نفسه "G".
2- "l` هي نفس" l`.
3. `o` أكبر من` e`. توقف هنا. السلسلة الأولى أكبر.

```smart header="ليس قاموسًا حقيقيًا ، ولكن ترتيب Unicode "
خوارزمية المقارنة الواردة أعلاه تكافئ تقريبًا تلك المستخدمة في القواميس أو دفاتر الهاتف ، ولكنها ليست هي نفسها تمامًا.

على سبيل المثال ، القضية مهمة. الحرف الكبير "A" لا يساوي الأحرف الصغيرة "a". أيهما أكبر؟ الأحرف الصغيرة "" أ "". لماذا ا؟ لأن الحرف الصغير يحتوي على فهرس أكبر في جدول الترميز الداخلي تستخدم JavaScript (Unicode). سنعود إلى تفاصيل محددة وعواقب ذلك في الفصل <info: string>.
```

## مقارنة الأنواع المختلفة

عند مقارنة قيم الأنواع المختلفة ، تحوّل JavaScript القيم إلى أرقام.

فمثلا:

```js run
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
```

بالنسبة إلى القيم المنطقية ، يصبح "true" "1" ويصبح "false" "0".

فمثلا: 

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

"" عنوان ذكي ومختصر = "نتيجة مضحكة"
من الممكن أنه في نفس الوقت:

- قيمتان متساويتان.
- واحد منهم "صحيح" باعتباره منطقيًا والآخر "خطأ" باعتباره منطقيًا.

فمثلا:
```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```


هذه النتيجة طبيعية من وجهة نظر JavaScript. يؤدي التحقق من المساواة إلى تحويل القيم باستخدام التحويل الرقمي (وبالتالي يصبح "0" `يُصبح` 0`) ، بينما يستخدم التحويل الصريح `Boolean` مجموعة أخرى من القواعد.
`` ``

## المساواة الصارمة

هناك مشكلة في التحقق المنتظم من المساواة `= =`. لا يمكن التمييز بين "0" و "false":


```js run
alert( 0 == false ); // true
```

يحدث الشيء نفسه بسلسلة فارغة:

```js run
alert( '' == false ); // true
```
يحدث هذا لأن المعاملات من أنواع مختلفة يتم تحويلها إلى أرقام من قبل عامل المساواة `==`. السلسلة الفارغة ، تمامًا مثل `false` ، تصبح صفرًا.

ماذا أفعل إذا أردنا التمييز بين "0" و "false"؟

** عامل المساواة الصارم `= =` يتحقق من المساواة بدون تحويل النوع. **

بمعنى آخر ، إذا كان "a" و "b" من أنواع مختلفة ، فإن "a === b" يُرجع على الفور "خطأ" دون محاولة تحويلها.

فلنجربها:

```js run
alert( 0 === false ); // false, because the types are different
```

هناك أيضًا عامل "صارم لعدم المساواة" `! ==` مشابه لـ '! = `.

عامل المساواة الصارم أطول قليلاً في الكتابة ، لكنه يوضح ما يحدث ويترك مساحة أقل للأخطاء.

## مقارنة مع لا شيء وغير محدد

هناك سلوك غير بديهي عند مقارنة "null" أو "undefined" بقيم أخرى.

للتحقق من المساواة الصارمة `= =`
: هذه القيم مختلفة ، لأن كل منها نوع مختلف.

    ```js run
    alert( null === undefined ); // false
    ```

للتحقق غير الصارم `= =`
: هناك قاعدة خاصة. هذان الزوجان "زوجان لطيفان": إنهما يساويان بعضهما البعض (بمعنى `= =`) ، ولكن ليس أي قيمة أخرى.

    ```js run
    alert( null == undefined ); // true
    ```


بالنسبة للرياضيات والمقارنات الأخرى `<> <=> =`
: "null / undefined" يتم تحويلها إلى أرقام: "null" تصبح "0" ، بينما "undefined" تصبح "NaN".

الآن دعونا نرى بعض الأشياء المضحكة التي تحدث عندما نطبق هذه القواعد. والأهم من ذلك ، كيف لا تقع في فخ معهم.

### نتيجة غريبة: صفر مقابل 0

دعنا نقارن `null` بصفر:

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```

رياضيا ، هذا غريب. تشير النتيجة الأخيرة إلى أن "القيمة" فارغة "أكبر من الصفر أو تساويه" ، لذا في إحدى المقارنات أعلاه ، يجب أن تكون "true" ، لكن كلاهما خطأ.

والسبب هو أن التحقق من المساواة `= =` والمقارنات `>> <> = <=` يعمل بشكل مختلف. تقوم المقارنات بتحويل `null` إلى رقم ، وتعاملها على أنها` 0`. لهذا السبب (3) `null> = 0` صحيحة و (1)` null> 0` خاطئة.

من ناحية أخرى ، يتم تحديد علامة المساواة `= =` لـ `undefined` و` null` بحيث لا يساوي أحدهما الآخر دون تحويلات ولا يساوي أي شيء آخر. لهذا السبب (2) `null == 0` خطأ.

### غير المحدد غير المقارن 

لا يجب مقارنة القيمة `undefined` بالقيم الأخرى:

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

لماذا يكره الصفر كثيرا؟ دائما خطأ!

نحصل على هذه النتائج للأسباب التالية:

- المقارنات `(1)` و `(2)` إرجاع `false` لأنه يتم تحويل` undefined` إلى `NaN` و` NaN` هي قيمة رقمية خاصة تُرجع `false` لجميع المقارنات.
- تحقق المساواة `((3)` تُرجع `false` لأن` undefined` تساوي فقط `null` و` undefined` ولا قيمة أخرى.

### تجنب المشاكل

لماذا راجعنا هذه الأمثلة؟ هل يجب أن نتذكر هذه الخصائص المميزة طوال الوقت؟ حسنًا ، ليس حقًا. في الواقع ، ستصبح هذه الأشياء الصعبة مألوفة تدريجيًا بمرور الوقت ، ولكن هناك طريقة صلبة للتهرب من المشاكل معها:

- فقط تعامل مع أي مقارنة بـ "undefined / null" باستثناء المساواة الصارمة `===` مع رعاية استثنائية.
- لا تستخدم المقارنات `> => <<=` مع متغير قد يكون `فارغًا / غير محدد` ، ما لم تكن متأكدًا حقًا مما تفعله. إذا كان المتغير يمكن أن يكون له هذه القيم ، تحقق منها بشكل منفصل.

## ملخص

- ترجع عوامل المقارنة قيمة منطقية.
- تتم مقارنة السلاسل حرفًا بحرف في ترتيب "القاموس".
- عند مقارنة القيم من أنواع مختلفة ، يتم تحويلها إلى أرقام (باستثناء التحقق من المساواة الصارم).
- القيمتان "null" و "undefined" تساوي `==` بعضها البعض ولا تساوي أي قيمة أخرى.
- كن حذرًا عند استخدام مقارنات مثل `>` أو `<` مع المتغيرات التي يمكن أن تكون أحيانًا `خالية / غير محددة '. يُعد التحقق من "null / undefined" بشكل منفصل فكرة جيدة.
