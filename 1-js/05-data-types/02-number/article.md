# الأرقام

في الجافاسكربت الحديثة هناك نوعان من الأرقام:

1. الأرقام المنتظمة في الجافاسكربت تخزن في هيئة [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision) 64-bit  , تعرف أيضا ب "double precision floating point numbers". هذه أرقام نستخدمها معظم الوقت، وسنتحدث عنهم في هذا الفصل.

2. أرقام ال BigInt,لتمثيل عدد صحيح من ال arbitrary length. وهناك حاجة إليهم في بعض الأحيان, لأن العدد العادي لا يمكن أن يتجاوز <code>2<sup>53</sup></code> أو يكون أقل من <code>-2<sup>53</sup></code>. كـَ  bigints تستخدم في مناطق خاصة قليلة
, نحن نخصص لهم فصل خاص <info:bigint>.

إذاً سنتحدث عن الأرقام العادية. دعونا نوسع معرفتنا بها.

## المزيد من الطرق لكتابة رقم


تخيلوا أننا بحاجة لكتابة مليار. الطريقة الواضحة هي:

```js
let billion = 1000000000;
```

لكن في الحياة الحقيقية, نحن عادة نتجنب كتابة سلسلة طويلة من الأصفار لأن من السهل نسيانها. أيضا، نحن كسالى. عادة سنكتب شيء مثل `"1bn"` لمليار أو `"7.3bn"` مقابل 7 مليارات و ثلاثمائة مليون. ونفس الشيء ينطبق على معظم الأعداد الكبيرة.

في الجافاسكربت, نخفض العدد بإضافة حرف `"e"` إلى العدد وتحديد عدد الأصفار:

```js run
let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (7,300,000,000)
```

بمعنى آخر, `"e"` يُضرب العدد فـ `1` مع عدد الأصفار المعطاة.

```js
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```

الآن لنكتب شيئاً صغيراً جداً. لنقل، 1 ميكروثانية (جزء من مليون من الثانية):

```js
let ms = 0.000001;
```

كما في السابق, استخدام `"e"` يمكن أن يساعد. إذا أردنا تجنب كتابة الأصفار بشكل واضح, يمكننا أن نقول نفس الشيء:

```js
let ms = 1e-6; // six zeroes to the left from 1
```

إذا عددنا الأصفار في `0.000001`, هناك ستة منهم. لذا طبيعياً `1e-6`.  

بمعنى آخر, رقم سالب بعد `"e"` يعني تقسيم علي 1 مع عدد معطى من الأصفار:

```js
// -3 divides by 1 with 3 zeroes
1e-3 = 1 / 1000 (=0.001)

// -6 divides by 1 with 6 zeroes
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

### Hex, الأرقام الثنائية و الأرقام الثماني

[Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) تُستخدم الارقام على نطاق واسع في جاڤاسكربت لتمثيل الالوان، رموز الحروف، وأشياء اخرى كثيرة. لذا بطبيعة الحال، هناك طريقة أقصر لكتابتهم: `0x` وبعد ذلك الرقم.

على سبيل المثال:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)
```

ونادراً ما يستخدم النظامان الثنائي والرقمي الثماني، ولكنهما يدعمان أيضاً باستخدام `0b` و  prefixes `0o` :


```js run
let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides
```

هناك فقط 3 نظم رقمية مع هذا الدعم. لأنظمة رقمية أخرى، يجب أن نستخدم ال  `parseInt` function (سنراها لاحقاً في هذا الفصل).

## toString(base)

ال  `num.toString(base)` method تقوم بـ إرجاع نص الذي يمثل ال `num` في النظام الرقمي مع المعطى `base`.

على سبيل المثال:
```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

ال `base` يمكن أن يختلف من `2` إلى  `36`. إفتراضياً هو `10`.

الحالات شائعة الاستخدام لهذا هي:

- **base=16** هو مُستخدَم لـ hex colors, تَشْفير حرف إلخ, الأرقام يمكن أن تكون
 `0..9` أو `A..F`.
- **base=2** غالباً من أجل تصحيح عمليات ال bitwise , الأرقام يمكن أن تكون `0` أو `1`.
- **base=36** هو الحد الأقصى, الأرقام يمكن أن تكون `0..9` أو `A..Z`. وتستخدم الأبجدية اللاتينية كلها لتمثيل الرقم. مضحك جداً,  لكن هذه حالة مهمة لـ `36` هو عندما نحتاج لتحويل رمز رقمي طويل إلى شيء أقصر, على سبيل المثال لجعل  url قصير. يمكن ببساطة تمثيل ذلك في النظام الرقمي مع
 base `36`:

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```warn header=" نقطتان لإستدعاء الـ method"
يرجى ملاحظة أن نقطتين في `123456..toString(36)` ليس خطأ مطبعي. إذا كنا نريد إستدعاء الـ method مباشرة على رقم, مثل `toString` في المثال أعلاه, إذن علينا أن نضع نقطتين `..` بعد ذلك.

إذا وضعنا نقطة واحدة
: `123456.toString(36)`, إذن سيكون هناك خطأ, لأن تركيب جملة الجافاسكربت يشير إلى الجزء العشري بعد النقطة الأولى. وإذا وضعنا نقطة أخرى, حينَئذٍ جافاسكربت تعرف أن الجزء العشري فارغ والآن تذهب الـ method.

أيضاً يمكن أن تكتب `(123456).toString(36)`.
```

## عملية التقريب

إحدى أكثر العمليات استخداماً عند التعامل مع الأرقام حين تقريبها.

وهناك عدة built-in functions لتقريب الأرقام:

`Math.floor`
: تقريب لأقل: `3.1` يصبح `3`, و `-1.1` يصبح `-2`.

`Math.ceil`
: تقريب لأعلي: `3.1` يصبح `4`, و `-1.1` يصبح `-1`.

`Math.round`
: تقريب إلى أقرب عدد صحيح: `3.1` يصبح `3`, `3.6` يصبح `4` و `-1.1` يصبح `-1`.

`Math.trunc` (غير مدعوم من قبل Internet Explorer)
: يزيل أيّ شئ بعد النقطة العشرية دون تقريب: `3.1` يصبح `3`, `-1.1` يصبح `-1`.

هذا الجدول يلخص الاختلافات بينهما :

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


هؤلاء الـ functions يغطون كل الطرق الممكنة للتعامل مع الجزء العشري من الرقم. ولكن ماذا لو أردنا أن نقرب الرقم إلى `n-th` رقم  بعد الرقم العشري؟

على سبيل المثال
, لدينا  `1.2345` ونريد أن نقربه إلى اقرب رقمين, لنحصل فقط على `1.23`.

وهناك طريقتان للقيام بذلك:

1. الضرب-و-القِسْمة.

    على سبيل المثال
, لتقريب الرقم إلى الرقم الثاني بعد الرقم العشري, يمكننا أن نضرب العدد في `100`, استدع function التقريب ثم اقسم علي ما سبق.
    ```js run
    let num = 1.23456;

    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. الـ  [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) method تقرب الرقم إلى `n` أرقام بعد النقطة و تقوم بإرجاع نص يمثل النتيجة.

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    هذا التقريب لأعلي أو لأقل أقرب قيمة مثل `Math.round`:

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    ونرجو أن تلاحظوا نتيجة الـ `toFixed` هو نص. إذا كان الجزء العشري أقل من المطلوب , الأصفار ملحقة بالنهاية:

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
    ```

    يمكننا تحويله إلى رقم باستخدام الـ unary plus أو الـ `Number()` استدعي : `+num.toFixed(5)` .

## حسابات غير دقيقة

داخِليًّا, الرقم مُمثل في هيئة    [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision) 64-bit , إذا هناك بالضبط 64 bits لتخزين رقم: 52 منها تستخدم لتخزين الأرقام, 11 منها يخزن موضع النقطة العشرية (هم صفر للأرقام الصحيحة), و 1 bit هو للاشارة.

إذا كان عدد كبير جدا, سيكون فائِض عن مخزن الـ 64-bit , اعطاء محتمل لانهائي :

```js run
alert( 1e500 ); // Infinity
```

وما قد يكون أقل وضوحا، ولكنه يحدث في كثير من الأحيان، هو فقدان الدقة .

تأملوا في هذا الاختبار :

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*
```

هذا صحيح، إذا تحققنا ما إذا كان مجموع `0.1` و `0.2` يكون `0.3`, سنحصل على `false`.

غريب! ما الأمر إذا لم يكن `0.3`؟

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

آخ! وهناك نتائج أكثر من المقارنة غير الصحيحة هنا. تخيلوا أنكم تصنعون موقع تسوق إلكتروني ويضع الزائر `$0.10` و `$0.20`البضائع في عربتهم. إجمالي الطلب سيكون `$0.30000000000000004`. هذا سيفاجئ أي شخص.

لكن لماذا يحدث هذا؟

يخزن الرقم في الذاكرة في شكله الثنائي، تسلسل من الـ bits - الآحاد والأصفار. لكن الكسور مثل `0.1`, `0.2` التي تبدو بسيطة في النظام العددي العشري هي في الواقع اجزاء لا نهاية لها في شكلها الثنائي.

بعبارة أخرى، ما هو `0.1`؟ إنه واحد مقسوم على عشرة `1/10`, عُشر واحد. وفي النظام العددي العشري يمكن تمثيل هذه الأرقام بسهولة.قارنها بثلث واحد: `1/3`. يصبح جزءا لا نهاية له `0.33333(3)`.

وعليه، فإن التقسيم حسب الأُس  `10` مضمونة للعمل بشكل جيد في النظام العشري، ولكن القسمة علي `3`  ليس كذلك. لنفس السبب ، في نظام الأرقام الثنائية, القسمة حسب الأُس `2` مضمونة للعمل, لكن `1/10` يصبح جزءا ثنائيا لانهائيا
.

ليس هناك طريقة لتخزين *0.1  بالضبط* أو *0.2  بالضبط* بإستخدام النظام الثنائي, مثل أنه لا توجد طريقة لتخزين الثلث ككسر عشري.

التنسيق الرقمي IEEE-754 يحلّ هذا بتقريب إلى أقرب رقم ممكن. وهذه القواعد الدائرية عادة لا تسمح لنا بأن نرى أن "الدقة الضئيلة تفقد"، ولكنها موجودة.

يمكننا أن نرى هذا في العمل:
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

وعندما نجمع رقمين، فإن  "خسارتهم الدقيقة" تجمع.

لهذا السبب `0.1 + 0.2` ليس بالضبط `0.3`.

```smart header="ليس فقط جافاسكربت"
توجد المسألة نفسها في العديد من لغات البرمجة الأخرى.

PHP, Java, C, Perl, Ruby يمنحون النتيجة نفسها لأنها تعتمد على الشكل الرقمي نفسه.
```

هل يمكننا العمل على ذلك؟ طبعا، الطريقة الأكثر موثوقية هي تقريب النتيجة بمساعدة الـ  [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) method :

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

يرجى ملاحظة ذلك `toFixed` دائماً تُعيد نص. وهي تضمن أن يكون لديه رقمين بعد النقطة العشرية. هذا في الواقع مريح إذا كان لدينا سوق إلكتروني و بالحاجة إلى إظهار `$0.30`. بالنسبة للحالات الأخري ، يمكننا استخدام الـ unary plus لإجباره على عدد :

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

ويمكننا أيضا مؤقتا أن نضرب الأعداد فـ (أو رقم أكبر) لتحويلها إلى أعداد صحيحة، والقيام بالرياضيات، ثم نقسمها. ثمّ، بينما نحن نَعمَلُ الرياضياتُ بالعدد الصحيح، الخطأ يُخفّضُ نوعاً ما، لَكنَّنا ما زِلنا نَحْصلُ عليه في القسمة:

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

وبالتالي، فإن نهج الضرب/التقسيم يقلل من الخطأ، ولكنه لا يزيله تماما.

أحياناً يمكننا أن نتفادى الكسور على الإطلاق. مثل إذا كنا نتعامل مع متجر، ثم يمكننا أن نخزن الأسعار بسنت بدلا من الدولار. لكن ماذا لو طبقنا خصم 30%؟ ومن الناحية العملية، قلّما يكون التفادي التام من الكسور ممكنا. فقط قربهم لقص "الذيول" عند الحاجة.

````smart header="الشيء المضحك"
Try running this:

```js run
// Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000
```

وهذه الحالة تشكو من نفس المسألة: فقدان الدقة. هناك 64 bits للعدد، 52 منها يمكن أن تستعمل لتخزين الأرقام، لكن هذا لايكفي. وهكذا تختفي أقل الأرقام أهمية.

الجافاسكربت لا تْسبّبُ خطأ في مثل هذه الأحداث. وتبذل قصارى جهدها لتضمين الرقم في الصيغة المرغوبة، ولكن من المؤسف أن هذه الصيغة ليست كبيرة بما يكفي.
````

```smart header="صفرين"
ومن النتائج المضحكة الأخرى للتمثيل الداخلي للأعداد وجود صفرين: `0` و `-0`.

ذلك لأن العلامة تمثل bit واحدة ، لذا يمكن ضبطها أو عدم ضبطها لأي رقم بما في ذلك صفر.

وفي معظم الحالات يكون التمييز غير ملحوظ لأن المشغلين مؤهلون لمعاملتهم على قدم المساواة.
```

## الاختبارات: isFinite and isNaN

تتذكروا هذه القيم العددية الخاصة؟

- `Infinity` (و `-Infinity`) هو قيمة رقمية خاصة هي أكبر (أقل) من أي شيء.
- `NaN` تمثل خطأ.

إنها تنتمي لهذا النوع `number`, ولكنها ليست أرقاما "عادية"، ولذلك هناك functions خاصة للتحقق منها :


- `isNaN(value)` تحوِّل الـ argument الخاصة بها إلى عدد ثم يختبرها على أنها `NaN`:

    ```js run
    alert( isNaN(NaN) ); // true
    alert( isNaN("str") ); // true
    ```

    ولكن هل نحتاج هذه الـ function ؟ ألا يمكننا فقط استخدام المقارنة `=== NaN`؟ آسف، لكن الجواب لا. القيمة `NaN` هي فريدة من حيث أنها لا تساوي أي شيء، بما في ذلك نفسها:

    ```js run
    alert( NaN === NaN ); // false
    ```

- `isFinite(value)` تحوِّل الـ argument الخاصة بها إلى رقم و تقوم بإرجاع `true` إذا كان رقماً عادياً، ليس `NaN/Infinity/-Infinity`:

    ```js run
    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, because a special value: NaN
    alert( isFinite(Infinity) ); // false, because a special value: Infinity
    ```

أحْيانًا `isFinite` يستخدم لإثبات ما إذا كانت القيمة النصية هي رقم منتظم:


```js run
let num = +prompt("Enter a number", '');

// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num) );
```

يرجى ملاحظة أن الفراغ النصي أو المسافات النصية فقط تُعامل على أنها `0` في جميع الـ functions الرقمية بما في ذلك `isFinite`.  

```smart header="قارن مع `Object.is`"

هناك built-in method خاصة  [`Object.is`](mdn:js/Object/is) تقارن القيم مثل `===`,ولكنه أكثر موثوقية لحالتين منفصلتين:

1. إنها تعمل مع `NaN`: `Object.is(NaN, NaN) === true`, هذا أمر جيد.
2. القِيَم `0` و `-0` مختلفين: `Object.is(0, -0) === false`, تقنياً هذا صحيح، لأن داخلياً الرقم له علامة bit التي قد تكون مختلفة حتى لو كانت كل الـ bits الأخرى أصفار.

وفي جميع الحالات الأخرى، `Object.is(a, b)` إنها نفس `a === b`.

وغالبا ما تستخدم طريقة المقارنة هذه في مواصفات جافاسكربت. عندما تحتاج خوارزمية داخلية للمقارنة بين قيمتين لكونها متماثلة تماماً، فإنها تستخدم `Object.is` (داخلياً تدعى [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)).
```


## parseInt and parseFloat

التحويل الرقمي يستخدم زائد `+` أو `Number()` إنه صارم. وإذا لم تكن القيمة رقماً بالضبط، فإنها تفشل:

```js run
alert( +"100px" ); // NaN
```

والاستثناء الوحيد هو المساحات في بداية النص أو في نهايتها، نظرا لتجاهلها.

ولكن في الحياة الواقعية غالبا ما يكون لدينا قيم بوحدات، مثل `"100px"` أو `"12pt"` في CSS. وفي العديد من البلدان أيضا، يأتي رمز العملة بعد الكمية، فلدينا أيضا `"19€"`وتُود أن تستخلص قيمة رقمية من ذلك.

هذا ما `parseInt` و `parseFloat`   لهذا الغرض.

إنهم  "يقرأون "  رقماً من نص حتى لا يستطيعوا. وفي حالة وقوع خطأ، يُعاد الرقم الذي جُمع. الـ function `parseInt` ترجع عدداً صحيحاً، بينما `parseFloat` سوف ترجع رقم عشري:

```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading
```

هناك مواقف مختلفة حين `parseInt/parseFloat` سترجع `NaN`. إنه يحدث عندما لا يمكن قراءة الأرقام:

```js run
alert( parseInt('a123') ); // NaN, the first symbol stops the process
```

````smart header="الـ argument الثاني من `parseInt(str, radix)`"
الـ `parseInt()` function لديها معامل ثاني إختياري. إنها تحدد قاعدة النظام الرقمي، لذا `parseInt` يمكن أيضا تمرير نصوص من أرقام الـ hex ، الأرقام الثنائية وما إلى ذلك:

```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works

alert( parseInt('2n9c', 36) ); // 123456
```
````

## functions رياضية أخرى

جافاسكربت لديها built-in [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object  يحتوي على مكتبة صغيرة من الـ functions الرياضية والثوابت.

بعض الامثلة:

`Math.random()`
: ترجع رقم عشوائي من 0 الي 1 (لا تشمل 1)

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (any random numbers)
    ```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: ترجع الأكبر/الأصغر من العدد الـ arbitrary  من الـ arguments.

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: ترجع `n` مرفوعة للأُس المعطي

    ```js run
    alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
    ```

هناك المزيد من الـ functions و الثوابت في الـ `Math` object, بما في ذلك علم المثلثات، الذي يمكنك العثور عليه في [docs for the Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object.

## مُلخّص

لكتابة الأرقام مع العديد من الأصفار:

- ألحق `"e"` مع عدد الأصفار. مثل: `123e6` إنها نفس `123` مع 6 أصفار `123000000`.
- رقم سالب بعد `"e"` يجعل العدد مقسوماً على 1 مع أصفار معطاة. على سَبيلِ المِثالِ. `123e-6` تعني `0.000123` (`123` المليون).

لأنظمة رقمية مختلفة:

-  يمكن كتابة الأرقام مباشرة في أنظمة الـ hex (`0x`), الثماني (`0o`) و الثنائية (`0b`) .
- `parseInt(str, base)` تحول النص `str` إلى عدد صحيح في النظام الرقمي مع الـ `base` المعطي, `2 ≤ base ≤ 36`.
- `num.toString(base)` تحول الرقم الي نص في النظام الرقمي مع الـ `base` المعطي.

لتحويل القيم مثل `12pt` و `100px` الي رقم:

- إستخدم `parseInt/parseFloat` أما التحويل "الليّن"، الذي يقرأ رقما من سلسلة نصية ثم يعيد القيمة التي يمكن أن يقرأوها قبل الخطأ.

للكسور:

- قرب بإستخدام `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` او `num.toFixed(precision)`.
- تأكد أن تتذكر أن هناك فقدان للدقة عند العمل مع الكسور.

المزيد من الـ functions الرياضية:

- انظر الي  [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object عندما تحتاجهم. المكتبة صغيرة جدا ولكنها يمكن أن تلبي الاحتياجات الأساسية.
