
# "var" القديم 

```smart header="هذه المقالة لفهم النصوص القديمة"
المعلومات الواردة في هذه المقالة مفيدة لفهم النصوص القديمة.

هذه ليست طريقة لكتابة النصوص الجديدة.
```

في الفصل الأول حول [المتغيرات](info:variables), ذكرنا ثلاث طرق لتعريف المتغير وهي:

1. `let`
2. `const`
3. `var`

`let` و `const` يتصرف بنفس الطريقة تمامًا فيما يتعلق بالبيئات المعجمية.

ولكن `var`  مختلف تمامًا ، نشأ قديمًا جدًا. بشكل عام ، لا يتم استخدامه في النصوص الحديثة ، ولكنه لا يزال يتوارى في النصوص القديمة.

إذا كنت لا تخطط لأستخدام مثل هذه النصوص البرمجية ، يمكنك تخطي هذا الفصل أو تأجيله ، ولكن هناك فرصة لمواجهته لاحقًا.

من النظرة الأولى ، يتصرف `var` بطريقة مشابهة بـ`let`. في تعريف المتغير:

```js run
function sayHi() {
  var phrase = "Hello"; // "let" بدلا من "var" , متغير محلي

  alert(phrase); // Hello
}

sayHi();

alert(phrase); // محدد غير phrase : خطأ
```

...ولكن هنا الأختلافات كالأتي.

## المتغير "var" ليس له نطاق محدد

المتغيرات بـ `var` ، إما تكون في نطاق الدالة  أو على النطاق العام. في الحالتين ليس لها نطاق محدد.

على سبيل المثال:

```js run
if (true) {
  var test = true; // "let" من بدلا "var" استخدم 
}

*!*
alert(test); // if صحيح ، المتغير موجود بعد 
*/!*
```

نظرًا لأن `var` يتجاهل النطاق او الكتلة المغلقة ، فلدينا الان متغير عام.


إذا استخدمنا `let test` بدلاً من `var test` ، فسيكون المتغير مرئيًا فقط داخل `if`:

```js run
if (true) {
  let test = true; // استخدم "let"
}

*!*
alert(test); // محدد غير test : خطأ
*/!*
```

الشيء نفسه بالنسبة للحلقات: لا يمكن أن يكون `var` داخل نطاق محدد أو محليًا داخل حلقات التكرار:
```js
for (var i = 0; i < 10; i++) {
  // ...
}

*!*
alert(i); // 10, مرئي بعد التكرار ، إنه متغير عام "i"
*/!*
```

إذا كان في نطاق محدد داخل دالة ، يصبح `var` متغيرًا على مستوى الدالة:
```js run
function sayHi() {
  if (true) {
    var phrase = "Hello";
  }

  alert(phrase); // تعمل
}

sayHi();
alert(phrase); // تحقق من (Developer  Console)phrase خطأ: لم يتم تحديد  
```

كما نرى ، `var` يخترق `if` أو `for` أو أي نطاق محدد برمجي أخر. هذا لأنه منذ فترة طويلة جافا سكريبت لم يكن لديها بيئات معجمية. و `var` لم يكن منهم.

## يتم تعريف  "var" في بداية الدالة

يتم تعريف  `var` في بداية الدالة (او عند بداية النص البرمجي).

بمعنى آخر ، يتم تعريف المتغيرات بـ`var` من بداية الدالة ، بغض النظر عن مكان التعريف (على افتراض أن التعريف ليس في الدوال المتداخلة).

إذن هذا هو الكود:

```js run
function sayHi() {
  phrase = "Hello";

  alert(phrase);

*!*
  var phrase;
*/!*
}
sayHi();
```

... هو تقنيًا مثل هذا (نقل عبارة var أعلاه):
```js run
function sayHi() {
*!*
  var phrase;
*/!*

  phrase = "Hello";

  alert(phrase);
}
sayHi();
```

... أو حتى مع هذا (تذكر ، يتم تجاهل النطاق المحدد):
```js run
function sayHi() {
  phrase = "Hello"; // (*)

  *!*
  if (false) {
    var phrase;
  }
  */!*

  alert(phrase);
}
sayHi();
```

يطلق الناس أيضًا على مثل هذا السلوك "hoisting" (رفع) ، لأن جميع المتغيرات مرفوعة في أعلى الدالة.

لذلك في المثال أعلاه ، لا يتم تنفيذ فرع `if (false)` أبدًا ، ولكن هذا لا يهم. تتم معالجة `var` بداخلها في بداية الدالة ، لذلك في لحظة `(*)` يوجد المتغير.

**يتم رفع التعريفات ، ولكن لا يتم رفع التعيينات.**

من الأفضل توضيح ذلك بمثال:

```js run
function sayHi() {
  alert(phrase);  

*!*
  var phrase = "Hello";
*/!*
}

sayHi();
```

يحتوي السطر `var var = "Hello"` على إجراءين:

1. تعريف المتغير  `var`
2. تعيين المتتغير `=`.

تتم معالجة التعريف في بداية تنفيذ الدالة ("hoisted") ، ولكن التعيين تعمل دائمًا في المكان الذي تظهر فيه. لذلك يعمل الكود بشكل أساسي على النحو التالي:

```js run
function sayHi() {
*!*
  var phrase; // يعمل التعريف في البداية ...
*/!*

  alert(phrase); // undefined = غير محدد

*!*
  phrase = "Hello"; // ... التعيين - عندما يصل تنفيذ الكود إلى ذلك.
*/!*
}

sayHi();
```

نظرًا لأنه تتم معالجة جميع تعريفات `var` في بداية الدالة ، يمكننا الرجوع إليها في أي مكان. لكن المتغيرات تكون  `undefined` حتى التعيين.

في كلا المثالين أعلاه ، يتم تشغيل `alert` بدون خطأ ، لأن المتغير `phrase` موجود. لكن قيمته لم يتم تعيينها بعد ، لذلك فهي تظهر `undefined`.

### IIFE

كما في الماضي ، كان هناك فقط `var` ، ولم يكن لديها رؤية على مستوى الكتلة ، اخترع المبرمجون طريقة لمحاكاة ذلك. ما فعلوه كان يسمى "الدوال التي يتم استدعاؤها على الفور" (اختصارها IIFE).

هذا ليس شيئًا يجب أن نستخدمه في الوقت الحاضر ، ولكن يمكنك العثور عليه في النصوص القديمة.

يبدو IIFE مثل كالأتي:

```js run
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
```

هنا يتم إنشاء دالة ويتم استدعاؤه على الفور. لذا يتم تنفيذ الكود على الفور ولها متغيرات خاصة بها.

يتم تغليف تعريف الدالة بقوس `({...} function)` ، لأنه عندما تلتقي JavaScript مع `"function"` في الكود الرئيسي ، فإنها تفهمها على أنها بداية تعريف الدالة. ولكن يجب أن يكون لتعريف الدالة اسم ، لذلك سيعطي هذا النوع من الكود خطأ:

```js run
// حاول تعريف الدالة واستدعاءها على الفور
function() { // <-- خطأ: تتطلب عبارات الدوال اسم دالة

  let message = "Hello";

  alert(message); // Hello

}();
```

حتى إذا قلنا: "حسنًا ، فلنضيف اسمًا" ، لن ينجح ذلك ، لأن جافا سكريبت لا تسمح باستدعاء تعريف الدالة على الفور:

```js run
// خطأ في بناء الجملة بسبب الأقواس أدناه

function go() {

}(); // <-- لا يمكن استدعاء تعريف الدالة على الفور
```

لذا ، فإن الأقواس حول الدالة هي خدعة لإظهار جافا سكريبت أن الدالة تم إنشاؤها في سياق تعبير آخر ، وبالتالي فهي تعبير الدالة: لا تحتاج إلى اسم ويمكن استدعاؤها على الفور.

توجد طرق أخرى إلى جانب الأقواس لإخبار جافا سكريبت بأننا نعني تعبير الدالة:

```js run
// IIFE طرق إنشاء  

(function() {
  alert("Parentheses around the function");
}*!*)*/!*();

(function() {
  alert("Parentheses around the whole thing");
}()*!*)*/!*;

*!*!*/!*function() {
  alert("Bitwise NOT operator starts the expression");
}();

*!*+*/!*function() {
  alert("Unary plus starts the expression");
}();
```

في جميع الحالات المذكورة أعلاه نعلن عن تعبير دالة ونقوم باستدعاؤها على الفور. دعنا نلاحظ مرة أخرى: في الوقت الحاضر لا يوجد سبب لكتابة مثل هذا الرمز.

## الملخص

هناك اختلافان رئيسيان لـ `var` مقارنة بـ` let / const`:

1.  متغيرات `var` ليس لها نطاق معين ، فهي مرئية كحد الأدنى على مستوى الدالة.
2.  تتم معالجة تعريف `var` في بداية الدالة (بداية النص للنصوص العامة).

هناك اختلاف ثانوي واحد إضافي يتعلق بالكائن العام ، والذي سنتناوله في الفصل التالي.

هذه الاختلافات تجعل `var` أسوأ من `let` معظم الوقت. متغيرات مستوى الكتلة هي شيء عظيم. لهذا السبب تم تقديم `let` في المعيار منذ فترة طويلة ، وهو الآن طريقة رئيسية (جنبًا إلى جنب مع `const`) تعريف عن متغير.