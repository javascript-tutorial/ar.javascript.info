# LocalStorage التخزين المحلي, sessionStorage تخزين الجلسة

كائنات تخزين الويب `localStorage` و `sessionStorage` تُتيح حفظَ أزواج المفتاح/القيمة في المتصفح.

المثير للاِهتمام بشأنهما هو أنَّ البيانات تبقى بعدَ تحديث الصفحة (بالنسبة لتخزين الجلسة `sessionStorage`) و حتى بعد إعادة تشغيل المتصفح بالكامل (بالنسبة للتخزين المحلي `localStorage`). سوف نرى ذلك قريبًا.

لدينا ملفات تعريف الارتباط بالفعل. لِمَ المزيد من الكائنات؟

- على عكس ملفات تعريف الارتباط، لا يتم إرسال كائنات تخزين الويب إلى الخادم مع كل طلب. لذلك السبب، بإمكاننا تخزين المزيد. أغلب المتصفحات تسمح بـ 2 ميقابايت من البيانات على الأقل 
- أيضا على عكس ملفات تعريف الارتباط، لا يمكن للخادم التحكم بكائنات التخزين عبر رؤوس الHTTP. كل شيء يتم عمله في جافا سكريبت
- التخزين مربوط بالأصل (المجال/البروتوكول/المنفذ الثلاثي) . مما يعني أنَّ البروتوكولات أو المجالات الفرعية المختلفة تستنتج كائنات تخزين مختلفة، ولا يمكنها الوصول إلى البيانات من بعضها البعض.

يقوم كِلا كائِنَي التخزين بتوفير توابع وخصائص متماثلة:

- `setItem(key, value)` -- خَزِّن زوج المفتاح/القيمة.
- `getItem(key)` -- احْصُل على القيمة بواسطة المفتاح.
- `removeItem(key)` -- قُم بإزالةالمفتاح مع قيمته.
- `clear()` -- احذف كل شيء.
- `key(index)` -- احْصُل على المفتاح في مكان محدَّد.
- `length` -- عدد العناصر المُخَزَّنة.

كما ترى، إنها تشبه مجموعة الخارطة `Map` (`setItem/getItem/removeItem`), لكنها تسمح أيضًا بالوصول عن طريق الفهرس بواسطة `key(index)`.

دعنا نرى كيف تعمل.

## localStorage مثال تجريبي للتخزين المحلي

الخصائص الأساسية للتخزين المحلي `localStorage` هي:

- مشترك بين جميع علامات التبويب والنوافذ من نفس الأصل.
- البيانات لا تنتهي صلاحيتها. بل تبقى حتى بعد إعادة تشغيل المتصفح وإعادة تشغيل النظام أيضًا.

على سبيل المثال، إذا قمت بتشغيل هذه الشَّفْرَة...

```js run
localStorage.setItem('test', 1);
```

...و قمت بإغلاق/فتح المتصفح أو قمت فقط بفتح الصفحة نفسها في نافذة أخرى، يمكنك عندها الحصول عليها كالتالي:

```js run
alert( localStorage.getItem('test') ); // 1
```

علينا فقط أن نكون على نفس الأصل (المجال/المنفذ/البروتوكول)، بينما يمكن أن يكون مسار الـurl مختلفًا.

التخزين المحلي `localStorage` مشترك بين جميع النوافذ من نفس الأصل، لذلك إذا قمنا بتعيين البيانات في أحد النوافذ فإن التغيير سيظهر في نافذة أخرى.

## الوصول الكائني

نستطيع أيضًا استخدام طريقة الكائن العادي في الحصول على/تعيين المفاتيح كالتالي:

```js run
// تعيين المفتاح
localStorage.test = 2;

// الحصول على المفتاح
alert( localStorage.test ); // 2

// إزالة المفتاح
delete localStorage.test;
```

مسموح بذلك لأسباب تاريخية وغالبًا ما يعمل، ولكن بشكل عام لا يوصى به للأسباب التالية:

1. إذا كان المفتاح من إنشاء المستخدم، فمن المحتمل أن يكون أيَّ شيء كـ `length` أو `toString`، أو أحد التوابع المضمنة في التخزين المحلي `localStorage`. في تلك الحالة ستعمل `getItem/setItem` بشكل صحيح، بينما سيتعثر الوصول الكائني:
    ```js run
    let key = 'length';
    localStorage[key] = 5; // lengthخطأ، لا يمكن تعيين الـ
    ```

2. هناك حدث للـ`storage` يتم إطلاقه عندما نقوم بتعديل البيانات. ذلك الحدث لا يتم إطلاقه في حال الوصول الكائني. سوف نرى ذلك لاحقًا في هذا الفصل.

## التكرار على المفاتيح

كما رأينا، تقوم التوابع بتوفير وظائف الـ "حصول/تعيين/إزالة بواسطة المفتاح". ولكن كيف يمكن الحصول على كل القيم أو المفاتيح المُخزَّنة؟ 

للأسف، كائنات التخزين ليست تِكْرارية.

أحد الطرق هو القيامُ بالتِكْرار عليها مثلَ التكرار على مصفوفةِِ ما:

```js run
for(let i=0; i<localStorage.length; i++) {
  let key = localStorage.key(i);
  alert(`${key}: ${localStorage.getItem(key)}`);
}
```

الطريقة الأخرى هي التكرار باستخدام `for key in localStorage`، كما نفعل مع الكائنات المعتادة.

تقوم بالتكرار على المفاتيح، ولكنها تُنتج قليلًا من الحقول المدمجة التي لا نحتاجها :

```js run
// محاولة غير جيدة
for(let key in localStorage) {
  alert(key); // والأشياء المدمجة الأخرى getItem ،setItem تقوم بإظهار
}
```

...لذلك نحن بحاجة إما إلى تصفية الحقول من الـprototype مع التحقق من `hasOwnProperty` :

```js run
for(let key in localStorage) {
  if (!localStorage.hasOwnProperty(key)) {
    continue; // وغيرها "setItem"، "getItem"تخطى المفاتيح المشابهة لـ
  }
  alert(`${key}: ${localStorage.getItem(key)}`);
}
```

...أو احصل على المفاتيح الخاصة بواسطة `Object.keys` ثم قم بالتكرار عليها إذا لزم الأمر :

```js run
let keys = Object.keys(localStorage);
for(let key of keys) {
  alert(`${key}: ${localStorage.getItem(key)}`);
}
```

الخيار الأخير يعمل، لأن `Object.keys` تقوم بإرجاع المفاتيح التي تنتمي إلى الكائن فقط، متجاهلةً الـ prototype.


## سلاسل نصّية فقط

يُرجى الملاحظة بأن كلًّا من المفتاح والقيمة يجب أن يكونا سلاسل نصية.

إذا كانا أي نوع آخر كرقم أو كائن فسيتم تحويلهما إلى سلسلة نصية تلقائيًّا:

```js run
sessionStorage.user = {name: "John"};
alert(sessionStorage.user); // [object Object]
```

على الرغم من ذلك يمكننا استخدام `JSON` لتخزين الكائنات:

```js run
sessionStorage.user = JSON.stringify({name: "John"});

// في وقتٍ ما لاحقًا
let user = JSON.parse( sessionStorage.user );
alert( user.name ); // John
```

من الممكن أيضًا تحويل كائن التخزين بأكمله إلى نص لغرض تصحيح الأخطاء مثلًا:

```js run
// لجعل الكائن يبدو أجمل JSON.stringify تم إضافة خيارات التنسيق إلى 
alert( JSON.stringify(localStorage, null, 2) );
```


## sessionStorage تخزين الجلسة

يُستخدم كائن تخزين الجلسة `sessionStorage` بشكل أقل بكثير من التخزين المحلي `localStorage`.

الخصائص والتوابع متماثلة، ولكنها محدودة بشكل أكبر:

- يتواجد تخزين الجلسة `sessionStorage` في علامة التبويب الحالية للمتصفح فقط .
  - سيكون هناك مساحة تخزين مختلفة لعلامة تبويب أخرى بنفس الصفحة.
  - لكنها مشتركة بين الiframes في نفس علامة التبويب (على افتراض أنهم من نفس الأصل)
- تبقى البيانات بعد تحديث الصفحة، ولكن ليس بعد إغلاق/فتح علامة التبويب.

دعونا نرى ذلك.

قُم بتشغيل هذه الشَفْرة...

```js run
sessionStorage.setItem('test', 1);
```

...ثم قُم بتحديث الصفحة. لا زال بإمكانك الآن الحصول على البيانات:

```js run
alert( sessionStorage.getItem('test') ); // بعد التحديث: 1
```

...ولكن إذا قمت بفتح نفس الصفحة في علامة تبويب أخرى، و أعدت المحاولة هناك، فإنَّ الشفرة في الأعلى ستقوم بإرجاع `null`، أي "لم يتم العثور على أي شيء".

وذلك بالضبط لأنَّ تخزين الجلسة `sessionStorage` ليس مرتبط بالأصل فحسب، بل بعلامة تبويب المتصفح أيضًا. لذلك السبب فإنَّ تخزين الجلسة `sessionStorage` يُستخدم بشكل مُقْتصَد.

## حدث التخزين

عندما يتم تحديث البيانات في التخزين المحلي `localStorage`  أو تخزين الجلسة `sessionStorage`، يتم إطلاق حدث التخزين [storage](https://www.w3.org/TR/webstorage/#the-storage-event)، بالخصائص التالية:

- `key` – المفتاح الذي تم تغييره (`null` إذا تم استدعاء `.clear()`).
- `oldValue` – القيمة القديمة (`null` إذا تمَّت إضافة المفتاح حديثًا).
- `newValue` – القيمة الجديدة (`null` إذا تمَّت إزالة المفتاح).
- `url` – عنوان الurl الخاص بالمستند الذي تم فيه التحديث.
- `storageArea` – إمَّا كائن التخزين المحلي `localStorage` أو تخزين الجلسة `sessionStorage` حيث تم التحديث.

الشيء المهم هو أنَّ الحدث يتم إطلاقه على جميع كائنات الـ `window` حيث الوصول إلى مساحة التخزين ممكن باستثناء الكائن الذي تسبَّبَ في ذلك.

دعنا نقوم بالتوضيح.

تخيل أنَّ لديك نافِذَتان بنفس الموقع الإلكتروني في كلٍّ منهما. حيث سيكون التخزين المحليُّ `localStorage` مشتركٌ بَينهُما.

```online
قد ترغبُ في فتح هذهِ الصفحةِ في نافذتين للمتصفح لاختبار الشفرة أدناه.
```

إذا كانت كِلا النافذتين تستمعان لـ `window.onstorage`، فستقوم كلًّا منهما بالتفاعل معَ التحديث الذي يتمُّ في النافذةِ الأخرى.

```js run
// تُطلق نتيجة تحديثات لنفس مساحة التخزين من مستندات أُخرى
window.onstorage = event => { // window.addEventListener('storage', event => { مُماثل لـ
  if (event.key != 'now') return;
  alert(event.key + ':' + event.newValue + " at " + event.url);
};

localStorage.setItem('now', Date.now());
```

يُرجى الملاحظة بأنَّ الحدث يحتوي أيضًا على: `event.url` -- عنوان الurl الخاص بالمستند الذي تم تحديث البيانات فيه.

يحتوي `event.storageArea` أيضًا على كائن التخزين-- الحدث هو نفسه لكلِِّ من تخزين الجلسة `sessionStorage` و التخزين المحلي `localStorage`، لذلك يقوم `event.storageArea` بالإشارة إلى كائن التخزين الذي تم تعديله. قد نرغب أيضًا بالقيام بتعيين شيءِِ ما في هذا الكائن كاستجابة لتغيير معين.

**يسمح ذلك لنوافذ مختلفة من نفس الأصل أن تتبادل الرسائل**

تدعم المتصفحات الحديثة أيضًا API قناة البث [Broadcast channel API](mdn:/api/Broadcast_Channel_API)، الAPI الخاص للاتصال بين النوافذ من نفس الأصل، يتمتع هذا الAPI بمميزات أكثر لكنه أقل دعمًا. هناك مكتبات تقوم بتغطية الجوانب الغير مدعومة في ذلك الAPI استنادًا إلى التخزين المحلي `localStorage` مما يجعلها متوفرة في كل مكان.

## ملخص

تقوم كائنات تخزين الويب التخزين المحلي `localStorage` و تخزين الجلسة `sessionStorage` بإتاحة تخزين المفتاح/القيمة في المتصفح.
- لابد أن يكون كلًّا من المفتاح `key` والقيمة `value` سلاسل نصية.
- الحد هو 5mb+، حسب المتصفح.
- صلاحيتها لا تنتهي.
- البيانات مرتبطة بالأصل (المجال/المنفذ/البروتوكول).

| `localStorage` | `sessionStorage` |
|----------------|------------------|
| مشتركة بين جميع علامات التبويب والنوافذ من نفس الأصل | من نفس الأصل iframesمرئية بداخل علامة تبويب المتصفح إضافةً للـ |
| تبقى بعد إعادة تشغيل المتصفح | تبقى بعد تحديث الصفحة (ولكن ليس بعد إغلاق علامة التبويب) |

API:

- `setItem(key, value)` -- تخزين زوج المفتاح/القيمة.
- `getItem(key)` -- الحصول على القيمة بواسطة المفتاح.
- `removeItem(key)` -- إزالة المفتاح مع قيمته.
- `clear()` -- حذف كل شيء.
- `key(index)` -- الحصول على رقم المفتاح `index`.
- `length` -- عدد العناصر المخزنة.
- للحصول على كل المفاتيح `Object.keys` استخدم.
- لا يتم إطلاقه `storage` عند الوصول إلى المفاتيح عن طريق خصائص الكائن فإنَّ حدث التخزين.

حدث التخزين:

- يتم إطلاقه في حال استدعاء `setItem`، `removeItem`، `clear`.
- يحتوي على كل البيانات الخاصة بالعملية (`key/oldValue/newValue`)، عنوان الـ`url` للمستند وكائن التخزين `storageArea`.
- يتم إطلاقه على كل كائنات الـ `window` التي يمكنها الوصول إلى مساحة التخزين ماعدا تلك التي قامت بتوليدها (عبر علامة تبويب بالنسبة لتخزين الجلسة `sessionStorage`، عموميًّا بالنسبة للتخزين المحلي `localStorage`).
