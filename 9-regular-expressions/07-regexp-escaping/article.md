# التخطى, الرموز الخاصة

كما رأينا, الشرطة المائلة للخلف `pattern:\` تستخدم للدلالة على فئات الرموز,على سبيل المثال `pattern:d\`. لذلك فهى رمز خاص فى المصطلحات العادية (تمام كما هو الحال فى النصوص العادية).

هناك رموز خاصة أخرى كذلك, التى لها معنى خاص فى المصطلحات العادية. يتم استخدامها لإجراء عمليات بحث أكثر قوة .
فيما يلى قائمة كاملة بها: `pattern:[\ ^ $ . | ? * + ( )`.

<<<<<<< HEAD
لا تحاول تذكر القائمة -- قريبا سنتعامل مع كل منهم على حدة وستعرفهم عن ظهر قلب تلقائيًا

## التخطى
=======
There are other special characters as well, that have special meaning in a regexp, such as `pattern:[ ] { } ( ) \ ^ $ . | ? * +`. They are used to do more powerful searches.

Don't try to remember the list -- soon we'll deal with each of them, and you'll know them by heart automatically.
>>>>>>> fe1c4a241f12a0939d1e0977cec6504ccd67201f

لنفترض أننا نريد إيجاد نقطة حرفيا. ليس "اى حرف"
لكن مجرد نقطة.

لاستخدام رمز خاص كرمز عادى, ضع قبلها شرطة مائلة للخلف: `pattern:.\`.

هذا يسمى أيضا "تخطى الرموز".

فمثلا:

```js run
alert('الفصل 5.1'.match(/\d\.\d/)); // 5.1 (تطابق!)
alert('الفصل 511'.match(/\d\.\d/)); // null (البحث عن نقطة حقيقية \.)
```

الأقواس أيضا رموز خاصة, لذلك إذا أردناهم, يجب استخدام `pattern:)\`. المثال أدناه يبحث عن `"()g"`:

```js run
alert('function g()'.match(/g\(\)/)); // "g()"
```

إذا كنا نبحث عن الشرطة المائلة للخلف `\`,إنها رمز خاص فى كلتا النصوص العادية و المصطلحات العادية, لذلك يجب أن نضاعفها.

```js run
alert('1\\2'.match(/\\/)); // '\'
```

## الشرطة المائلة

رمز الشرطة المائلة `'/'` ليس رمز خاص ولكن فى جافا سكريبت يتم استخدامه لفتح وإغلاق المصطلح العام: `pattern:/...نمط.../`,لذلك يجب تخطيها أيضا.

هذا ما يبدو عليه البحث عن الشرطة المائلة `'/'`:

```js run
alert('/'.match(/\//)); // '/'
```

من ناحية أخرى
إذا كنا لا نستخدم `pattern:/.../`, ولكن قمنا بإنشاء مصطلع عام باستخدام `new RegExp`, فلا داعى لتخطيها:

```js run
alert('/'.match(new RegExp('/'))); // وجدت /
```

## new RegExp

إذا كنا بصدد إنشاء تعبير عادي باستخدام `new RegExp`, كذلك لا يمكن تخطى `/`,
ولكن بحاجة الى استخدام تخطى أخر.

فمثلا, ضع فى اعتبارك هذا:

```js run
let regexp = new RegExp('d.d');

alert('الفصل 5.1'.match(regexp)); // null
```

البحث المماثل في أحد الأمثلة السابقة يعمل مع `pattern:/\d\.\d/`, ولكن `new RegExp("\d\.\d")` لا يعمل , لماذا؟

السبب هوا أن الشرط المائلة "تستهلك" بواسطة النص, كما قد نتذكر, النصوص العادية لديها رموز خاصة بها, مثل `n\`, والشرطة المائلة للخلف تستخدم فى التخطى.

<<<<<<< HEAD
إليك كيف ينظر الى "\d\.\d" :
=======
Here's how "\d\.\d" is perceived:
>>>>>>> fe1c4a241f12a0939d1e0977cec6504ccd67201f

```js run
alert('d.d'); // d.d
```

النصوص الاقتباسية "تستهلك" الشرط المائلة للخلف وتفسرهم لأنفسهم, فمثلا:

- `n\` -- يضع سطر جديد,
- `u1234\` -- يصبح رمز اليونيكود بالرقم المحدد,
- ... وعندما لا يكون هناك معنى خاص: مثل `pattern:d\` أو `z\`, عندئذ يتم إزالة الشرطة المائلة للخلف ببساطة.

لذلك `new RegExp` تحصل على النصوص بلا شرط مائلة للخلف. لهذا السبب لا يعمل البحث

ولإصلاحها ، نحتاج إلى مضاعفة الشرط المائلة للخلف, لأن النصوص المقتبسة تحول `\\` الى `\`:

```js run
*!*
let regStr = "\\d\\.\\d";
*/!*
alert(regStr); // \d\.\d (صحيحة)

let regexp = new RegExp(regStr);

alert( "الفصل 5.1".match(regexp) ); // 5.1
```

## الملخص

- To search for special characters `pattern:[ \ ^ $ . | ? * + ( )` literally, we need to prepend them with a backslash `\` ("escape them").
- We also need to escape `/` if we're inside `pattern:/.../` (but not inside `new RegExp`).
- When passing a string to `new RegExp`, we need to double backslashes `\\`, cause string quotes consume one of them.
